"""
Contributions API endpoints for user-submitted metadata corrections and stream additions.
"""

import asyncio
import logging
from datetime import datetime
from typing import Any, Literal

import pytz
from fastapi import APIRouter, Depends, HTTPException, Query, status
from pydantic import BaseModel, Field
from sqlmodel import col, func, select
from sqlmodel.ext.asyncio.session import AsyncSession

from api.routers.content.anonymous_utils import resolve_uploader_identity
from api.routers.user.auth import require_auth, require_role
from db.crud.media import get_media_by_external_id
from db.database import get_async_session, get_read_session
from db.enums import ContributionStatus, UserRole
from db.models import Contribution, ContributionSettings, Stream, StreamSuggestion, TelegramStream, User
from utils.notification_registry import send_pending_contribution_notification

router = APIRouter(prefix="/api/v1/contributions", tags=["Contributions"])
logger = logging.getLogger(__name__)

CONTRIBUTION_TYPES = ["metadata", "stream", "torrent", "telegram", "youtube", "nzb", "http", "acestream"]
_CONTRIBUTION_TYPE_PATTERN = "^(" + "|".join(CONTRIBUTION_TYPES) + ")$"
POINT_ELIGIBLE_IMPORT_TYPES = {"stream", "torrent", "telegram", "youtube", "nzb", "http", "acestream"}
PROCESSABLE_IMPORT_TYPES = {"torrent", "telegram", "youtube", "nzb", "http", "acestream"}


# ============================================
# Pydantic Schemas
# ============================================


class ContributionCreate(BaseModel):
    """Request schema for creating a contribution."""

    contribution_type: str = Field(..., pattern=_CONTRIBUTION_TYPE_PATTERN)
    target_id: str | None = None  # meta_id or stream_id
    data: dict[str, Any]  # The contribution data


class ContributionReview(BaseModel):
    """Request schema for reviewing a contribution."""

    status: ContributionStatus = Field(..., description="APPROVED or REJECTED")
    review_notes: str | None = None


class ContributionBulkReviewRequest(BaseModel):
    """Request schema for bulk reviewing pending contributions."""

    action: Literal["approve", "reject"]
    contribution_type: str | None = Field(None, pattern=_CONTRIBUTION_TYPE_PATTERN)
    review_notes: str | None = None


class BulkContributionReviewResponse(BaseModel):
    """Bulk contribution review result counters."""

    approved: int
    rejected: int
    skipped: int


class ContributionResponse(BaseModel):
    """Response schema for a contribution."""

    id: str  # UUID string
    user_id: int | None
    username: str | None = None
    contribution_type: str
    target_id: str | None  # External ID (IMDb, TMDB)
    media_id: int | None = None  # Internal MediaFusion media ID
    mediafusion_id: str | None = None  # Canonical internal ID: mf:<media_id>
    data: dict[str, Any]
    status: str
    reviewed_by: str | None = None  # User ID string
    reviewer_name: str | None = None  # Reviewer's username or auto label
    reviewed_at: datetime | None = None
    review_notes: str | None = None
    created_at: datetime
    updated_at: datetime | None = None

    class Config:
        from_attributes = True


class ContributionListResponse(BaseModel):
    """Response schema for paginated contribution list."""

    items: list[ContributionResponse]
    total: int
    page: int
    page_size: int
    has_more: bool


class ContributionStats(BaseModel):
    """Contribution statistics response."""

    total_contributions: int
    pending: int
    approved: int
    rejected: int
    by_type: dict[str, int]


# ============================================
# Helper Functions
# ============================================


def contribution_to_response(
    contribution: Contribution,
    username: str | None = None,
    media_id: int | None = None,
    reviewer_name: str | None = None,
) -> ContributionResponse:
    """Convert a Contribution model to response schema."""
    return ContributionResponse(
        id=contribution.id,
        user_id=contribution.user_id,
        username=username,
        contribution_type=contribution.contribution_type,
        target_id=contribution.target_id,
        media_id=media_id,
        mediafusion_id=f"mf:{media_id}" if media_id is not None else None,
        data=contribution.data,
        status=contribution.status.value if hasattr(contribution.status, "value") else str(contribution.status),
        reviewed_by=contribution.reviewed_by,
        reviewer_name=reviewer_name,
        reviewed_at=contribution.reviewed_at,
        review_notes=contribution.review_notes,
        created_at=contribution.created_at,
        updated_at=contribution.updated_at,
    )


async def get_username_map(session: AsyncSession, user_ids: set[int]) -> dict[int, str | None]:
    """Get a map of user_id -> username for contribution lists."""
    if not user_ids:
        return {}

    result = await session.exec(select(User.id, User.username).where(User.id.in_(user_ids)))
    rows = result.all()
    return {user_id: username for user_id, username in rows}


async def get_contribution_username(session: AsyncSession, user_id: int | None) -> str | None:
    """Get username for a single contribution's user_id."""
    if user_id is None:
        return None

    result = await session.exec(select(User.username).where(User.id == user_id))
    return result.first()


async def get_reviewer_name_map(session: AsyncSession, reviewed_by_values: set[str]) -> dict[str, str]:
    """Build reviewed_by value to reviewer display name map."""
    if not reviewed_by_values:
        return {}

    reviewer_map: dict[str, str] = {}
    reviewer_ids: set[int] = set()

    for reviewed_by in reviewed_by_values:
        if reviewed_by == "auto":
            reviewer_map[reviewed_by] = "Auto-approved"
            continue
        try:
            reviewer_ids.add(int(reviewed_by))
        except (TypeError, ValueError):
            reviewer_map[reviewed_by] = reviewed_by

    if reviewer_ids:
        result = await session.exec(select(User.id, User.username).where(User.id.in_(reviewer_ids)))
        for reviewer_id, username in result.all():
            reviewer_map[str(reviewer_id)] = username or f"User #{reviewer_id}"

    return reviewer_map


async def get_reviewer_name(session: AsyncSession, reviewed_by: str | None) -> str | None:
    """Resolve reviewer label from reviewed_by value."""
    if not reviewed_by:
        return None
    reviewer_map = await get_reviewer_name_map(session, {reviewed_by})
    return reviewer_map.get(reviewed_by)


def _extract_contribution_meta_candidates(contribution: Contribution) -> list[str]:
    """Collect potential media identifiers from contribution payload."""
    data = contribution.data if isinstance(contribution.data, dict) else {}
    candidates: list[str] = []
    for raw_value in (
        data.get("mediafusion_id"),
        data.get("meta_id"),
        contribution.target_id,
    ):
        if isinstance(raw_value, str):
            value = raw_value.strip()
            if value and value not in candidates:
                candidates.append(value)
    return candidates


async def resolve_contribution_media_id(session: AsyncSession, contribution: Contribution) -> int | None:
    """Resolve contribution identifiers to internal MediaFusion media ID."""
    for candidate in _extract_contribution_meta_candidates(contribution):
        media = await get_media_by_external_id(session, candidate)
        if media:
            return media.id
    return None


async def process_telegram_import(
    session: AsyncSession,
    contribution_data: dict,
    user: User | None,
) -> dict:
    """Publish an already-created Telegram stream when a contribution is approved."""
    del user  # Telegram stream promotion does not require user context.

    file_unique_id = contribution_data.get("file_unique_id")
    file_id = contribution_data.get("file_id")

    if not file_unique_id and not file_id:
        return {"status": "error", "message": "Missing Telegram file identifier in contribution data"}

    query = select(TelegramStream)
    if file_unique_id:
        query = query.where(TelegramStream.file_unique_id == file_unique_id)
    else:
        query = query.where(TelegramStream.file_id == file_id)

    result = await session.exec(query)
    telegram_stream = result.first()
    if not telegram_stream:
        return {"status": "error", "message": "Telegram stream not found for this contribution"}

    stream = await session.get(Stream, telegram_stream.stream_id)
    if not stream:
        return {"status": "error", "message": "Telegram stream record is missing"}

    if not stream.is_public:
        stream.is_public = True
        await session.flush()

    return {"status": "success", "stream_id": stream.id}


def _append_review_note(existing_notes: str | None, note: str) -> str:
    """Append a system-generated note preserving optional moderator notes."""
    return f"{existing_notes or ''}\n{note}".strip()


async def get_contribution_settings(session: AsyncSession) -> ContributionSettings:
    """Get contribution settings row or create the default one."""
    result = await session.exec(select(ContributionSettings).where(ContributionSettings.id == "default"))
    settings = result.first()
    if settings:
        return settings

    settings = ContributionSettings(id="default")
    session.add(settings)
    await session.flush()
    return settings


def calculate_contribution_level(points: int, settings: ContributionSettings) -> str:
    """Map contribution points to the configured level."""
    if points >= settings.expert_threshold:
        return "expert"
    if points >= settings.trusted_threshold:
        return "trusted"
    if points >= settings.contributor_threshold:
        return "contributor"
    return "new"


async def award_import_approval_points(
    session: AsyncSession,
    user_id: int | None,
    contribution_type: str,
    logger: logging.Logger | None = None,
) -> bool:
    """Award points for approved import contributions when eligible."""
    if user_id is None or contribution_type not in POINT_ELIGIBLE_IMPORT_TYPES:
        return False

    user = await session.get(User, user_id)
    if not user:
        if logger:
            logger.warning("Skipping points award: user_id=%s not found", user_id)
        return False

    settings = await get_contribution_settings(session)
    user.contribution_points = max(0, user.contribution_points + settings.points_per_stream_edit)
    user.stream_edits_approved += 1
    user.contribution_level = calculate_contribution_level(user.contribution_points, settings)
    session.add(user)

    if logger:
        logger.info(
            "Awarded %s points for %s contribution to user_id=%s",
            settings.points_per_stream_edit,
            contribution_type,
            user_id,
        )

    return True


def get_import_processor(contribution_type: str):
    """Return the import processor for a contribution type.

    Imports are local to avoid circular imports with dedicated import routers.
    """
    if contribution_type == "torrent":
        from api.routers.content.torrent_import import process_torrent_import

        return process_torrent_import
    if contribution_type == "nzb":
        from api.routers.content.nzb_import import process_nzb_import

        return process_nzb_import
    if contribution_type == "youtube":
        from api.routers.content.youtube_import import process_youtube_import

        return process_youtube_import
    if contribution_type == "http":
        from api.routers.content.http_import import process_http_import

        return process_http_import
    if contribution_type == "acestream":
        from api.routers.content.acestream_import import process_acestream_import

        return process_acestream_import
    if contribution_type == "telegram":
        return process_telegram_import
    return None


async def _apply_contribution_review(
    session: AsyncSession,
    contribution: Contribution,
    review_status: ContributionStatus,
    reviewer: User,
    review_notes: str | None,
    logger: logging.Logger,
) -> None:
    """Apply review decision and optional import processing to a contribution."""
    contribution.status = review_status
    contribution.reviewed_by = str(reviewer.id)
    contribution.reviewed_at = datetime.now(pytz.UTC)
    contribution.review_notes = review_notes

    if review_status != ContributionStatus.APPROVED:
        return

    await award_import_approval_points(
        session,
        contribution.user_id,
        contribution.contribution_type,
        logger,
    )

    if contribution.contribution_type not in PROCESSABLE_IMPORT_TYPES:
        return

    try:
        process_fn = get_import_processor(contribution.contribution_type)
        if process_fn is None:
            raise ValueError(f"Unsupported contribution type: {contribution.contribution_type}")

        # Anonymous contributions have no contributor user_id by design.
        contributor = await session.get(User, contribution.user_id) if contribution.user_id is not None else None
        contribution_data = dict(contribution.data or {})
        contribution_data["is_public"] = True
        contribution.data = contribution_data
        import_result = await process_fn(session, contribution_data, contributor)

        if import_result.get("status") == "success":
            contribution.review_notes = _append_review_note(
                review_notes,
                f"Import successful: stream_id={import_result.get('stream_id')}",
            )
        elif import_result.get("status") == "exists":
            contribution.review_notes = _append_review_note(review_notes, "Content already exists in database")

    except Exception as e:
        logger.exception(f"Failed to process contribution import on approval: {e}")
        contribution.review_notes = _append_review_note(review_notes, f"Import processing failed: {str(e)}")


# ============================================
# API Endpoints - User
# ============================================


@router.get("", response_model=ContributionListResponse)
async def list_contributions(
    contribution_type: str | None = Query(None, pattern=_CONTRIBUTION_TYPE_PATTERN),
    contribution_status: ContributionStatus | None = Query(None),
    page: int = Query(1, ge=1),
    page_size: int = Query(20, ge=1, le=100),
    user: User = Depends(require_auth),
    session: AsyncSession = Depends(get_read_session),
):
    """
    List user's contributions with pagination.
    Regular users see only their own contributions.
    Moderators and admins can see all contributions.
    """
    # Build base query - moderators+ see all, others see only their own
    is_mod_or_admin = user.role in [UserRole.MODERATOR, UserRole.ADMIN]

    query = select(Contribution)
    count_query = select(func.count(Contribution.id))

    if not is_mod_or_admin:
        query = query.where(Contribution.user_id == user.id)
        count_query = count_query.where(Contribution.user_id == user.id)

    if contribution_type:
        query = query.where(Contribution.contribution_type == contribution_type)
        count_query = count_query.where(Contribution.contribution_type == contribution_type)

    if contribution_status:
        query = query.where(Contribution.status == contribution_status)
        count_query = count_query.where(Contribution.status == contribution_status)

    # Get total count
    total_result = await session.exec(count_query)
    total = total_result.one()

    # Get paginated results
    offset = (page - 1) * page_size
    query = query.order_by(col(Contribution.created_at).desc()).offset(offset).limit(page_size)
    result = await session.exec(query)
    items = result.all()

    username_map = await get_username_map(session, {item.user_id for item in items if item.user_id is not None})
    reviewer_name_map = await get_reviewer_name_map(session, {item.reviewed_by for item in items if item.reviewed_by})
    media_ids = await asyncio.gather(*(resolve_contribution_media_id(session, item) for item in items))

    return ContributionListResponse(
        items=[
            contribution_to_response(
                item,
                username_map.get(item.user_id),
                media_ids[idx],
                reviewer_name_map.get(item.reviewed_by) if item.reviewed_by else None,
            )
            for idx, item in enumerate(items)
        ],
        total=total,
        page=page,
        page_size=page_size,
        has_more=(offset + len(items)) < total,
    )


@router.get("/stats", response_model=ContributionStats)
async def get_contribution_stats(
    user: User = Depends(require_auth),
    session: AsyncSession = Depends(get_read_session),
):
    """Get contribution statistics for the current user (including stream suggestions)."""

    # ====== Contribution model counts ======
    contrib_total_result = await session.exec(
        select(func.count(Contribution.id)).where(Contribution.user_id == user.id)
    )
    contrib_total = contrib_total_result.one()

    contrib_pending_result = await session.exec(
        select(func.count(Contribution.id)).where(
            Contribution.user_id == user.id,
            Contribution.status == ContributionStatus.PENDING,
        )
    )
    contrib_pending = contrib_pending_result.one()

    contrib_approved_result = await session.exec(
        select(func.count(Contribution.id)).where(
            Contribution.user_id == user.id,
            Contribution.status == ContributionStatus.APPROVED,
        )
    )
    contrib_approved = contrib_approved_result.one()

    contrib_rejected_result = await session.exec(
        select(func.count(Contribution.id)).where(
            Contribution.user_id == user.id,
            Contribution.status == ContributionStatus.REJECTED,
        )
    )
    contrib_rejected = contrib_rejected_result.one()

    # ====== StreamSuggestion model counts ======
    stream_total_result = await session.exec(
        select(func.count(StreamSuggestion.id)).where(StreamSuggestion.user_id == user.id)
    )
    stream_total = stream_total_result.one()

    stream_pending_result = await session.exec(
        select(func.count(StreamSuggestion.id)).where(
            StreamSuggestion.user_id == user.id,
            StreamSuggestion.status == "pending",
        )
    )
    stream_pending = stream_pending_result.one()

    stream_approved_result = await session.exec(
        select(func.count(StreamSuggestion.id)).where(
            StreamSuggestion.user_id == user.id,
            StreamSuggestion.status.in_(["approved", "auto_approved"]),
        )
    )
    stream_approved = stream_approved_result.one()

    stream_rejected_result = await session.exec(
        select(func.count(StreamSuggestion.id)).where(
            StreamSuggestion.user_id == user.id,
            StreamSuggestion.status == "rejected",
        )
    )
    stream_rejected = stream_rejected_result.one()

    # ====== By type ======
    by_type = {}
    for ctype in CONTRIBUTION_TYPES:
        type_result = await session.exec(
            select(func.count(Contribution.id)).where(
                Contribution.user_id == user.id,
                Contribution.contribution_type == ctype,
            )
        )
        by_type[ctype] = type_result.one()

    by_type["stream_suggestions"] = stream_total

    # ====== Combined totals ======
    return ContributionStats(
        total_contributions=contrib_total + stream_total,
        pending=contrib_pending + stream_pending,
        approved=contrib_approved + stream_approved,
        rejected=contrib_rejected + stream_rejected,
        by_type=by_type,
    )


@router.get("/{contribution_id}", response_model=ContributionResponse)
async def get_contribution(
    contribution_id: str,
    user: User = Depends(require_auth),
    session: AsyncSession = Depends(get_read_session),
):
    """Get a specific contribution by ID."""
    contribution = await session.get(Contribution, contribution_id)

    if not contribution:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Contribution not found",
        )

    # Only owner or moderators+ can view
    is_mod_or_admin = user.role in [UserRole.MODERATOR, UserRole.ADMIN]
    if contribution.user_id != user.id and not is_mod_or_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not authorized to view this contribution",
        )

    username = await get_contribution_username(session, contribution.user_id)
    reviewer_name = await get_reviewer_name(session, contribution.reviewed_by)
    media_id = await resolve_contribution_media_id(session, contribution)
    return contribution_to_response(contribution, username, media_id, reviewer_name)


@router.post("", response_model=ContributionResponse, status_code=status.HTTP_201_CREATED)
async def create_contribution(
    data: ContributionCreate,
    user: User = Depends(require_auth),
    session: AsyncSession = Depends(get_async_session),
):
    """Submit a new contribution.

    Torrent and stream imports are auto-approved if the user is active.
    Metadata contributions require manual review.
    """
    is_anonymous = data.data.get("is_anonymous") is True

    # Moderators/admins auto-approve regardless of anonymity.
    # Other users auto-approve torrent/stream imports only when active and non-anonymous.
    is_privileged_reviewer = user.role in {UserRole.MODERATOR, UserRole.ADMIN}
    should_auto_approve = is_privileged_reviewer or (
        (not is_anonymous)
        and user.is_active
        and data.contribution_type
        in (
            "torrent",
            "stream",
        )
    )

    initial_status = ContributionStatus.APPROVED if should_auto_approve else ContributionStatus.PENDING

    contribution = Contribution(
        user_id=None if is_anonymous else user.id,
        contribution_type=data.contribution_type,
        target_id=data.target_id,
        data=data.data,
        status=initial_status,
        # Mark auto-approved contributions
        reviewed_by="auto" if should_auto_approve else None,
        reviewed_at=datetime.now(pytz.UTC) if should_auto_approve else None,
        review_notes=(
            "Auto-approved: Privileged reviewer"
            if is_privileged_reviewer
            else ("Auto-approved: Active user content import" if should_auto_approve else None)
        ),
    )

    session.add(contribution)
    if should_auto_approve:
        await award_import_approval_points(
            session,
            contribution.user_id,
            contribution.contribution_type,
            logger,
        )
    await session.commit()
    await session.refresh(contribution)

    if contribution.status == ContributionStatus.PENDING:
        uploader_name, _ = resolve_uploader_identity(
            user,
            is_anonymous,
            data.data.get("anonymous_display_name"),
        )
        await send_pending_contribution_notification(
            {
                "contribution_id": contribution.id,
                "contribution_type": contribution.contribution_type,
                "target_id": contribution.target_id,
                "uploader_name": uploader_name,
                "data": contribution.data,
            }
        )

    media_id = await resolve_contribution_media_id(session, contribution)
    reviewer_name = await get_reviewer_name(session, contribution.reviewed_by)
    return contribution_to_response(
        contribution,
        user.username if contribution.user_id is not None else None,
        media_id,
        reviewer_name,
    )


@router.delete("/{contribution_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_contribution(
    contribution_id: str,
    user: User = Depends(require_auth),
    session: AsyncSession = Depends(get_async_session),
):
    """
    Delete a contribution.
    Users can only delete their own pending contributions.
    Admins can delete any contribution.
    """
    contribution = await session.get(Contribution, contribution_id)

    if not contribution:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Contribution not found",
        )

    is_admin = user.role == UserRole.ADMIN
    is_owner = contribution.user_id == user.id
    is_pending = contribution.status == ContributionStatus.PENDING

    if not is_admin and not (is_owner and is_pending):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Cannot delete this contribution. Only pending contributions can be deleted by their owner.",
        )

    await session.delete(contribution)
    await session.commit()


# ============================================
# API Endpoints - Moderator/Admin
# ============================================


@router.get("/review/pending", response_model=ContributionListResponse)
async def list_pending_contributions(
    contribution_type: str | None = Query(None, pattern=_CONTRIBUTION_TYPE_PATTERN),
    page: int = Query(1, ge=1),
    page_size: int = Query(20, ge=1, le=100),
    user: User = Depends(require_role(UserRole.MODERATOR)),
    session: AsyncSession = Depends(get_read_session),
):
    """List all pending contributions for review. Moderator+ only."""
    query = select(Contribution).where(Contribution.status == ContributionStatus.PENDING)
    count_query = select(func.count(Contribution.id)).where(Contribution.status == ContributionStatus.PENDING)

    if contribution_type:
        query = query.where(Contribution.contribution_type == contribution_type)
        count_query = count_query.where(Contribution.contribution_type == contribution_type)

    # Get total count
    total_result = await session.exec(count_query)
    total = total_result.one()

    # Get paginated results
    offset = (page - 1) * page_size
    query = query.order_by(col(Contribution.created_at).asc()).offset(offset).limit(page_size)
    result = await session.exec(query)
    items = result.all()

    username_map = await get_username_map(session, {item.user_id for item in items if item.user_id is not None})
    reviewer_name_map = await get_reviewer_name_map(session, {item.reviewed_by for item in items if item.reviewed_by})
    media_ids = await asyncio.gather(*(resolve_contribution_media_id(session, item) for item in items))

    return ContributionListResponse(
        items=[
            contribution_to_response(
                item,
                username_map.get(item.user_id),
                media_ids[idx],
                reviewer_name_map.get(item.reviewed_by) if item.reviewed_by else None,
            )
            for idx, item in enumerate(items)
        ],
        total=total,
        page=page,
        page_size=page_size,
        has_more=(offset + len(items)) < total,
    )


@router.patch("/{contribution_id}/review", response_model=ContributionResponse)
async def review_contribution(
    contribution_id: str,
    review: ContributionReview,
    user: User = Depends(require_role(UserRole.MODERATOR)),
    session: AsyncSession = Depends(get_async_session),
):
    """Review a contribution (approve or reject). Moderator+ only.

    If approved, supported content-import contributions are processed and imported.
    """
    logger = logging.getLogger(__name__)

    contribution = await session.get(Contribution, contribution_id)

    if not contribution:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Contribution not found",
        )

    if contribution.status != ContributionStatus.PENDING:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Contribution already reviewed with status: {contribution.status}",
        )

    await _apply_contribution_review(
        session,
        contribution,
        review.status,
        user,
        review.review_notes,
        logger,
    )

    session.add(contribution)
    await session.commit()
    await session.refresh(contribution)

    username = await get_contribution_username(session, contribution.user_id)
    reviewer_name = await get_reviewer_name(session, contribution.reviewed_by)
    media_id = await resolve_contribution_media_id(session, contribution)
    return contribution_to_response(contribution, username, media_id, reviewer_name)


@router.post("/review/bulk", response_model=BulkContributionReviewResponse)
async def bulk_review_contributions(
    request: ContributionBulkReviewRequest,
    user: User = Depends(require_role(UserRole.MODERATOR)),
    session: AsyncSession = Depends(get_async_session),
):
    """Bulk review all pending contributions, optionally filtered by type."""
    logger = logging.getLogger(__name__)
    review_status = ContributionStatus.APPROVED if request.action == "approve" else ContributionStatus.REJECTED

    query = select(Contribution).where(Contribution.status == ContributionStatus.PENDING)
    if request.contribution_type:
        query = query.where(Contribution.contribution_type == request.contribution_type)

    result = await session.exec(query.order_by(col(Contribution.created_at).asc()))
    contributions = result.all()

    approved = 0
    rejected = 0
    skipped = 0

    for contribution in contributions:
        if contribution.status != ContributionStatus.PENDING:
            skipped += 1
            continue

        await _apply_contribution_review(
            session,
            contribution,
            review_status,
            user,
            request.review_notes,
            logger,
        )
        session.add(contribution)
        if review_status == ContributionStatus.APPROVED:
            approved += 1
        else:
            rejected += 1

    await session.commit()

    return BulkContributionReviewResponse(
        approved=approved,
        rejected=rejected,
        skipped=skipped,
    )


@router.get("/review/stats", response_model=ContributionStats)
async def get_all_contribution_stats(
    user: User = Depends(require_role(UserRole.MODERATOR)),
    session: AsyncSession = Depends(get_read_session),
):
    """Get overall contribution statistics (including stream suggestions). Moderator+ only."""

    # ====== Contribution model counts ======
    contrib_total_result = await session.exec(select(func.count(Contribution.id)))
    contrib_total = contrib_total_result.one()

    contrib_pending_result = await session.exec(
        select(func.count(Contribution.id)).where(Contribution.status == ContributionStatus.PENDING)
    )
    contrib_pending = contrib_pending_result.one()

    contrib_approved_result = await session.exec(
        select(func.count(Contribution.id)).where(Contribution.status == ContributionStatus.APPROVED)
    )
    contrib_approved = contrib_approved_result.one()

    contrib_rejected_result = await session.exec(
        select(func.count(Contribution.id)).where(Contribution.status == ContributionStatus.REJECTED)
    )
    contrib_rejected = contrib_rejected_result.one()

    # ====== StreamSuggestion model counts ======
    stream_total_result = await session.exec(select(func.count(StreamSuggestion.id)))
    stream_total = stream_total_result.one()

    stream_pending_result = await session.exec(
        select(func.count(StreamSuggestion.id)).where(StreamSuggestion.status == "pending")
    )
    stream_pending = stream_pending_result.one()

    stream_approved_result = await session.exec(
        select(func.count(StreamSuggestion.id)).where(StreamSuggestion.status.in_(["approved", "auto_approved"]))
    )
    stream_approved = stream_approved_result.one()

    stream_rejected_result = await session.exec(
        select(func.count(StreamSuggestion.id)).where(StreamSuggestion.status == "rejected")
    )
    stream_rejected = stream_rejected_result.one()

    # ====== By type ======
    by_type = {}
    for ctype in CONTRIBUTION_TYPES:
        type_result = await session.exec(
            select(func.count(Contribution.id)).where(Contribution.contribution_type == ctype)
        )
        by_type[ctype] = type_result.one()

    by_type["stream_suggestions"] = stream_total

    # ====== Combined totals ======
    return ContributionStats(
        total_contributions=contrib_total + stream_total,
        pending=contrib_pending + stream_pending,
        approved=contrib_approved + stream_approved,
        rejected=contrib_rejected + stream_rejected,
        by_type=by_type,
    )
