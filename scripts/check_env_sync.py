#!/usr/bin/env python3
from __future__ import annotations

import argparse
import ast
import re
import sys
from dataclasses import dataclass
from pathlib import Path


ROOT_DIR = Path(__file__).resolve().parents[1]
CONFIG_PATH = ROOT_DIR / "db/config.py"
DOC_PATH = ROOT_DIR / "docs/env-reference.md"
DOCKER_ENV_SAMPLE_PATH = ROOT_DIR / "deployment/docker-compose/.env-sample"
K8S_LOCAL_DEPLOYMENT_PATH = ROOT_DIR / "deployment/k8s/local-deployment.yaml"

K8S_APP_CONTAINERS = ("mediafusion", "dramatiq-worker")


@dataclass(frozen=True)
class SettingField:
    name: str
    env_name: str
    annotation: str
    required: bool
    default_repr: str


def _is_ellipsis(node: ast.AST) -> bool:
    return isinstance(node, ast.Constant) and node.value is Ellipsis


def _is_field_call(node: ast.AST) -> bool:
    return isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == "Field"


def _field_required_from_call(node: ast.Call) -> bool:
    if node.args and _is_ellipsis(node.args[0]):
        return True
    for keyword in node.keywords:
        if keyword.arg == "default" and _is_ellipsis(keyword.value):
            return True
    return False


def _field_default_from_call(node: ast.Call) -> str:
    for keyword in node.keywords:
        if keyword.arg == "default":
            return ast.unparse(keyword.value)
        if keyword.arg == "default_factory":
            return f"default_factory={ast.unparse(keyword.value)}"
    if node.args and not _is_ellipsis(node.args[0]):
        return ast.unparse(node.args[0])
    return ""


def _normalize_default(default_repr: str) -> str:
    normalized = default_repr.strip().replace("\n", " ")
    if len(normalized) > 80:
        return f"{normalized[:77]}..."
    return normalized


def _markdown_cell(content: str) -> str:
    return content.replace("|", "\\|")


def extract_settings_fields(config_path: Path) -> list[SettingField]:
    source = config_path.read_text(encoding="utf-8")
    module = ast.parse(source)

    settings_class: ast.ClassDef | None = None
    for node in module.body:
        if isinstance(node, ast.ClassDef) and node.name == "Settings":
            settings_class = node
            break

    if settings_class is None:
        raise RuntimeError("Settings class not found in db/config.py")

    fields: list[SettingField] = []

    for node in settings_class.body:
        if not isinstance(node, ast.AnnAssign):
            continue
        if not isinstance(node.target, ast.Name):
            continue
        if node.target.id.startswith("_"):
            continue

        value = node.value
        annotation = ast.unparse(node.annotation)
        required = value is None
        default_repr = ""

        if isinstance(value, ast.Call) and _is_field_call(value):
            required = _field_required_from_call(value)
            default_repr = _field_default_from_call(value)
        elif value is not None:
            default_repr = ast.unparse(value)

        field_name = node.target.id
        fields.append(
            SettingField(
                name=field_name,
                env_name=field_name.upper(),
                annotation=annotation,
                required=required,
                default_repr=default_repr,
            )
        )

    return fields


def render_env_reference(fields: list[SettingField]) -> str:
    required_fields = [field for field in fields if field.required]
    optional_fields = [field for field in fields if not field.required]

    lines = [
        "# Environment Variable Reference",
        "",
        "This file is auto-generated from `db/config.py` using `scripts/check_env_sync.py`.",
        "Do not edit this file manually.",
        "",
        f"- Total variables: **{len(fields)}**",
        f"- Required variables: **{len(required_fields)}**",
        f"- Optional variables: **{len(optional_fields)}**",
        "",
        "## Required Variables",
        "",
        "| Env Var | Field | Type |",
        "|---|---|---|",
    ]

    for field in required_fields:
        lines.append(
            f"| `{_markdown_cell(field.env_name)}` | `{_markdown_cell(field.name)}` | `{_markdown_cell(field.annotation)}` |"
        )

    lines.extend(
        [
            "",
            "## All Variables",
            "",
            "| Env Var | Field | Required | Type | Default |",
            "|---|---|---|---|---|",
        ]
    )

    for field in fields:
        required_label = "yes" if field.required else "no"
        default_value = "â€”" if field.required else f"`{_markdown_cell(_normalize_default(field.default_repr))}`"
        lines.append(
            f"| `{_markdown_cell(field.env_name)}` | `{_markdown_cell(field.name)}` | {required_label} | `{_markdown_cell(field.annotation)}` | {default_value} |"
        )

    lines.append("")
    return "\n".join(lines)


def extract_env_names_from_env_sample(file_path: Path) -> set[str]:
    env_names: set[str] = set()
    pattern = re.compile(r"^([A-Z][A-Z0-9_]*)\s*=")
    for raw_line in file_path.read_text(encoding="utf-8").splitlines():
        line = raw_line.strip()
        if not line or line.startswith("#"):
            continue
        match = pattern.match(line)
        if match:
            env_names.add(match.group(1))
    return env_names


def extract_k8s_container_env_names(file_path: Path, container_name: str) -> set[str]:
    content = file_path.read_text(encoding="utf-8")
    container_marker = f"- name: {container_name}"
    start_index = content.find(container_marker)
    if start_index == -1:
        return set()

    next_doc_index = content.find("\n---", start_index)
    next_container_index = content.find("\n      - name:", start_index + 1)
    block_end_candidates = [index for index in (next_doc_index, next_container_index) if index != -1]
    block_end = min(block_end_candidates) if block_end_candidates else len(content)
    block = content[start_index:block_end]

    return set(re.findall(r"- name:\s*([A-Z][A-Z0-9_]*)", block))


def check_required_env_coverage(fields: list[SettingField]) -> list[str]:
    required_env_names = {field.env_name for field in fields if field.required}
    errors: list[str] = []

    docker_env_names = extract_env_names_from_env_sample(DOCKER_ENV_SAMPLE_PATH)
    missing_in_docker = sorted(required_env_names - docker_env_names)
    if missing_in_docker:
        errors.append(
            "Missing required env vars in deployment/docker-compose/.env-sample: " + ", ".join(missing_in_docker)
        )

    for container_name in K8S_APP_CONTAINERS:
        k8s_env_names = extract_k8s_container_env_names(K8S_LOCAL_DEPLOYMENT_PATH, container_name)
        missing_in_container = sorted(required_env_names - k8s_env_names)
        if missing_in_container:
            errors.append(
                f"Missing required env vars in deployment/k8s/local-deployment.yaml "
                f"container '{container_name}': {', '.join(missing_in_container)}"
            )

    return errors


def check_docs_sync(expected_content: str) -> list[str]:
    if not DOC_PATH.exists():
        return [f"Missing generated docs file: {DOC_PATH.relative_to(ROOT_DIR)}"]
    current_content = DOC_PATH.read_text(encoding="utf-8")
    if current_content != expected_content:
        return [
            "Generated docs are out of date: docs/env-reference.md",
            "Run: python scripts/check_env_sync.py --write",
        ]
    return []


def write_docs(expected_content: str) -> None:
    DOC_PATH.write_text(expected_content, encoding="utf-8")


def main() -> int:
    parser = argparse.ArgumentParser(
        description=(
            "Validate environment-variable synchronization between db/config.py, "
            "generated docs, and deployment templates."
        )
    )
    parser.add_argument(
        "--write",
        action="store_true",
        help="Regenerate docs/env-reference.md from db/config.py.",
    )
    args = parser.parse_args()

    fields = extract_settings_fields(CONFIG_PATH)
    expected_docs = render_env_reference(fields)

    if args.write:
        write_docs(expected_docs)
        print(f"Updated {DOC_PATH.relative_to(ROOT_DIR)}")
        return 0

    errors = check_docs_sync(expected_docs)
    errors.extend(check_required_env_coverage(fields))

    if errors:
        for error in errors:
            print(f"ERROR: {error}")
        return 1

    print("Environment variable docs and deployment templates are in sync.")
    return 0


if __name__ == "__main__":
    sys.exit(main())
